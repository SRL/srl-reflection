const
  R_EVILBOB_PORTAL = 8987;
  R_EVILBOB_COOKINGPOT = 8985;
  R_EVILBOB_DEPOSITBOX = 32930;
  R_EVILBOB_FISHINGSPOT = 8986;
  R_EVILBOB_SMALLFISHINGNET = 6209;
  R_EVILBOB_MIDDLE_X = 3422;
  R_EVILBOB_MIDDLE_Y = 4777;
  R_EVILBOB_NPC_HEIGHT = 448;
  R_EVILBOB_SERVANTNAME = 'Servant';
  R_EVILBOB_EVILBOBNAME = 'Evil Bob';
  R_EVILBOB_DIRECTIONINTERFACE = 186;
  R_EVILBOB_DIRECTIONCOMP = 0;
  R_EVILBOB_DIRECTIONCOMPTEXT = 'Evil Bob wants fish from the Fishing spots beyond this statue.';
  R_EVILBOB_CLICKCONT = 'Click here to continue';
  R_EVILBOB_FISHID1 = 6202;
  R_EVILBOB_FISHID2 = 6206;
  R_EVILBOB_FISHIDUNCOOKED1 = 6200;
  R_EVILBOB_FISHIDUNCOOKED2 = 6204;

{*******************************************************************************
function R_InScapeRune: Boolean;
by: Cstrike
Description: Checks if in Evil bob's ScapeRune random.
*******************************************************************************}
function R_InScapeRune: Boolean;
begin
  Result := ValidNPC(R_EVILBOB_EVILBOBNAME);
end;

{*******************************************************************************
procedure R_ScapeRuneDepositItems (ItemsToDeposit : Integer);
by: Cstrike
Description: Deposists that number in the DropBox.
*******************************************************************************}
procedure R_ScapeRuneDepositItems (ItemsToDeposit : Integer);
begin
  if not LoggedIn then Exit;
  R_Debug('Depositing '+inttostr(ItemsToDeposit)+' items to make space', 'ScapeRune');
end;

{*******************************************************************************
procedure R_ScapeRuneDestroyBadFish;
by: Cstrike, fixed by Harry
Description: Destroys bad fish if we for whatever reason happen to get one.
*******************************************************************************}
procedure R_ScapeRuneDestroyFish;
var
  DestroyArray : TIntegerArray;
  DropThis: TInvItem;
  i, t : Integer;
begin
  if not LoggedIn then Exit;
  DestroyArray := [R_EVILBOB_FISHID1, R_EVILBOB_FISHID2, R_EVILBOB_FISHIDUNCOOKED1, R_EVILBOB_FISHIDUNCOOKED2];
  for i:=0 to high(DestroyArray) do
  begin
    if R_ItemExists(DestroyArray[i], DropThis) then
    begin
      R_Debug('Destroying improper fish.', 'ScapeRune');
      R_ClickItem(DropThis.slot, False, 'estroy');
      wait (500+random(500));
      // Wait for interface to pop up
      MarkTime(t);
      repeat
        wait (50);
      until (ValidInterface(94)) or (TimeFromMark(t) > 6000)
      // Click interface
      Wait(42+Random(300));
      MarkTime(t);
      repeat
        wait (50);
        if (GetInterfaceText(94, 3) = 'Yes.') then
        begin
          Mouse (322,387, 3, 3, true);
          wait (1000+random(500));
        end;
      until (not ValidInterface(94)) or (TimeFromMark(t) > 2000)
    end
  end;
end;

{*******************************************************************************
procedure R_ScapeRuneClickToContinue (Int, Comp : Integer);
by: Cstrike
Description: Determines the proper direction to go.
*******************************************************************************}
procedure R_ScapeRuneClickToContinue (Int, Comp : Integer);
var
  t : Integer;
begin
  if not LoggedIn then Exit;
  MarkTime (t);
  if (not ValidInterface(Int)) then Exit;
  repeat
    if (GetInterfaceText (Int, Comp) = R_EVILBOB_CLICKCONT) then
      Mouse(303, 452, 72, 7, True);
  until (not (GetInterfaceText (Int, Comp) = R_EVILBOB_CLICKCONT)) or (TimeFromMark(t) > 8000)
end;

{*******************************************************************************
procedure R_ScapeRuneWalkToCenter;
by: Cstrike
Description: Walks to center.
*******************************************************************************}
procedure R_ScapeRuneWalkToCenter;
begin
  if not LoggedIn then Exit;
  if not WalkToTile (Tile(R_EVILBOB_MIDDLE_X, R_EVILBOB_MIDDLE_Y), 2, 0) then
  begin
    if TileOnMM (Tile(R_EVILBOB_MIDDLE_X+6, R_EVILBOB_MIDDLE_Y)) then
    begin
      WalkToTile (Tile(R_EVILBOB_MIDDLE_X+6, R_EVILBOB_MIDDLE_Y), 2, 0);
      R_Debug('Moving from east to center', 'ScapeRune');
    end else
    if TileOnMM (Tile(R_EVILBOB_MIDDLE_X, R_EVILBOB_MIDDLE_Y+6)) then
    begin
      WalkToTile (Tile(R_EVILBOB_MIDDLE_X, R_EVILBOB_MIDDLE_Y+6), 2, 0);
      R_Debug('Moving from north to center', 'ScapeRune');
    end else
    if TileOnMM (Tile(R_EVILBOB_MIDDLE_X-6, R_EVILBOB_MIDDLE_Y)) then
    begin
      WalkToTile (Tile(R_EVILBOB_MIDDLE_X-6, R_EVILBOB_MIDDLE_Y), 2, 0);
      R_Debug('Moving from west to center', 'ScapeRune');
    end else
    if TileOnMM (Tile(R_EVILBOB_MIDDLE_X, R_EVILBOB_MIDDLE_Y-6)) then
    begin
      WalkToTile (Tile(R_EVILBOB_MIDDLE_X, R_EVILBOB_MIDDLE_Y-6), 2, 0);
      R_Debug('Moving from south to center', 'ScapeRune');
    end;
    WalkToTile (Tile(R_EVILBOB_MIDDLE_X, R_EVILBOB_MIDDLE_Y), 2, 0);
  end;
end;

{*******************************************************************************
procedure R_ScapeRuneClickContBobAll;
by: Cstrike
Description: Returns true if no interfaces are available to chat with Bob.
*******************************************************************************}
procedure R_ScapeRuneClickContBobAll;
var
  t : Integer;
begin
  MarkTime (t);
  repeat
    R_ScapeRuneClickToContinue(64,5);
    R_ScapeRuneClickToContinue(65,6);
    R_ScapeRuneClickToContinue(66,7);
    R_ScapeRuneClickToContinue(241,5);
    R_ScapeRuneClickToContinue(242,6);
    R_ScapeRuneClickToContinue(243,7);
  until ((not (ValidInterface(64))) and (not (ValidInterface(65))) and (not (ValidInterface(66)))
        and (not (ValidInterface(241))) and (not (ValidInterface(242))) and (not (ValidInterface(243)))
          or (TimeFromMark(t) > 30000))
  R_Debug('No more bob chat interfaces up', 'ScapeRune');
end;

{*******************************************************************************
function R_ScapeRuneTalkToServant: Boolean;
by: Cstrike
Description: Checks if in Evil bob's ScapeRune random.
*******************************************************************************}
function R_ScapeRuneTalkToServantStart: Boolean;
var
  NPC : TNPC;
  TP : TPoint;
  t : Integer;
begin
  if not LoggedIn then Exit;
  Result := False;
  if FindNPC(R_EVILBOB_SERVANTNAME, NPC) then
  begin
    if not TileOnMS (NPC.Tile, 0) then R_ScapeRuneWalkToCenter;
    if TileOnMS (NPC.Tile, 0) then
    begin
      TP := TileToMS (NPC.Tile, 0);
      Mouse (TP.x, TP.y, 2, 3, false);
      if R_ChooseOptionMulti (['Talk','alk','-to']) then
      begin
        MarkTime(t);
        // Wait until we start chatting with the Servant
        repeat
          If (ValidInterface(64))
            or (ValidInterface(65))
              or (ValidInterface(241))
                or (ValidInterface(242))
                  or (ValidInterface(186)) then Break;
          wait (50);
        until (TimeFromMark(t) > 10000)
        // If theres an error...
        if (TimeFromMark(t) > 10000) then
        begin
          R_Debug('We clicked to talk with the Servant but its not happening...', 'ScapeRune');
          Exit;
        end;
        // Failsafe in case we talked to the Servant already
        if (ValidInterface(186)) then
        begin
          R_Debug('Servant skipped to the showing of the statue, skipping to finding fish location function', 'ScapeRune');
          Result := True;
          Exit;
        end;
        // If we haven't talked to the Servant, then shut her up:
        MarkTime(t);
        repeat
          R_ScapeRuneClickToContinue (64, 5);
          R_ScapeRuneClickToContinue (241, 5);
          R_ScapeRuneClickToContinue (65, 6);
          R_ScapeRuneClickToContinue (242, 6);
          wait (200+random(500));
        until (ValidInterface(186)) or (TimeFromMark(t) > 20000)
        Result := True;
      end;
    end;
  end else
  begin
    R_Debug('Could not index Servant, walking to center', 'ScapeRune');
    R_ScapeRuneWalkToCenter;
  end;
end;

{*******************************************************************************
function R_ScapeRuneGetFishingNet: Boolean;
by: Cstrike
Description: Gets a fishing net.
*******************************************************************************}
function R_ScapeRuneGetFishingNet: Boolean;
var
  GroundItemArr : TGroundItemArray;
  TileToGetItem : TTile;
  i, t : Integer;
  TP : TPoint;
begin
  if not LoggedIn then Exit;
  Result := False;

  if (R_CountItem(R_EVILBOB_SMALLFISHINGNET) > 0) then
  begin
    R_Debug('Fishing net is in inventory', 'ScapeRune');
    Result := True;
    Exit;
  end;

  // Try 3x to get a fishing net
  for i:=1 to 3 do
  begin
    R_Debug('Attempt #'+inttostr(i)+'/3 to get fishing net', 'ScapeRune');

    // Pick a tile to pick it up from
    case random(6) of
      0: TileToGetItem := Tile(3416, 4786);
      1: TileToGetItem := Tile(3412, 4784);
      2: TileToGetItem := Tile(3414, 4768);
      3: TileToGetItem := Tile(3429, 4784);
      4: TileToGetItem := Tile(3432, 4783);
      5: TileToGetItem := Tile(3431, 4772);
      6: TileToGetItem := Tile(3429, 4769);
    end;

    // Move to location
    if TileOnMM (TileToGetItem) then WalkToTile (TileToGetItem, 2, 0)
    else
    begin
      R_ScapeRuneWalkToCenter;
      WalkToTile (TileToGetItem, 2, 0);
    end;

    // Pick up item
    if TileOnMS (TileToGetItem, 0) then
    begin
      MarkTime (t);
      repeat
        GroundItemArr := GetItemsAt (TileToGetItem);
        if high (GroundItemArr) < 0 then Break;
        TP := TileToMS (TileToGetItem, 0);
        Mouse (TP.x, TP.y, 1, 1, true);
        wait (2000+random(3000));
      until (TimeFromMark(t) > 20000) or (R_CountItem(R_EVILBOB_SMALLFISHINGNET) > 0)
    end else
    begin
      R_Debug('Could not find fishing net at Tile('+inttostr(TileToGetItem.x)+','+inttostr(TileToGetItem.y)+')', 'ScapeRune');
    end;

    // If successful...
    if (R_CountItem(R_EVILBOB_SMALLFISHINGNET) > 0) then
    begin
      Result := true;
      R_Debug('Successfully obtained a fishing net to complete task with', 'ScapeRune');
      Exit;
    end;
  end;
end;

{*******************************************************************************
function R_ScapeRuneDetermineDirectionOfFishAndWalkTo (var TileToFishAt : TTile) : Boolean;
by: Cstrike
Description: Determines the proper direction to go. Returns 'n, e, s, w'.
Returns true when walking in proper direction. It also puts a tile in the var
TileToFishAt for later functions
*******************************************************************************}
function R_ScapeRuneDetermineDirectionOfFishAndWalkTo (var TileToFishAt : TTile) : Boolean;
var
  FishObj : TRSObjectArray;
  FishObjTile, TileToArrive : TTile;
  i, j : Integer;
  TP : TPoint;
  Direction : String;
begin
  if not LoggedIn then Exit;
  Result := False;
  Direction := 'none';
  TileToFishAt := Tile(0,0); // Failsafe
  FishObjTile := Tile(0,0); // Failsafe
  if (GetInterfaceText (R_EVILBOB_DIRECTIONINTERFACE, R_EVILBOB_DIRECTIONCOMP)
    = R_EVILBOB_DIRECTIONCOMPTEXT) then
  begin
    for j:=1 to 3 do
    begin
      R_Debug('Searching for proper fishing pool attempt #'+inttostr(j), 'ScapeRune');
      wait (6500+random(3200)); // Let camera calibrate to pause
      FishObj := GetObjectsByIDEx([R_EVILBOB_FISHINGSPOT], OBJECT_TYPE_INTERACTABLE, 24);

      // If we found more than 4 fish pools or none, we have a problem
      if (high(FishObj) < 0) then
      begin
        R_Debug('Had trouble getting fish location ['+inttostr(high(FishObj))+']', 'ScapeRune');
        Exit;
      end else // Here we check tile on MS
      begin
        for i:=0 to high (FishObj) do
        begin
          if (TileOnMS (FishObj[i].Tile, 0)) then
          begin
            R_Debug('Found fish tile on screen, tile indexed', 'ScapeRune');
            FishObjTile := FishObj[i].Tile;
            Break;
          end;
        end;
      end;
      if FishObjTile.x > 0 then Break; // If we have found the tile, stop trying
    end;

    // N: Y should be -ve cause its higher, X shouldnt differ by abs dist of 7
    if (iabs(R_EVILBOB_MIDDLE_X - FishObjTile.x) < 7) and
      (R_EVILBOB_MIDDLE_Y - FishObjTile.y <= -7) then Direction := 'n';

    // E: X should be -ve cause its more right, Y shouldnt differ by abs dist of 7
    if (R_EVILBOB_MIDDLE_X - FishObjTile.x <= -7) and
      (iAbs(R_EVILBOB_MIDDLE_Y - FishObjTile.y) < 7) then Direction := 'e';

    // S: Y should be +ve cause its lower, X shouldnt differ by abs dist of 7
    if (iabs(R_EVILBOB_MIDDLE_X - FishObjTile.x) < 7) and
      (R_EVILBOB_MIDDLE_Y - FishObjTile.y >= 7) then Direction := 's';

    // W: X should be +ve cause its more left, Y shouldnt differ by abs dist of 7
    if (R_EVILBOB_MIDDLE_X - FishObjTile.x >= 7) and
      (iAbs(R_EVILBOB_MIDDLE_Y - FishObjTile.y) < 7) then Direction := 'w';

    // Walking part
    if Direction = 'none' then
    begin
      R_Debug('Warning: Error occured, could not find direction to walk for Evil Bob ScapeRune!', 'ScapeRune');
      Exit;
    end else
    begin
      R_Debug('FishObjTile: ' + ToStr(FishObjTile) + ' Dir: ' + Direction, 'ScapeRune');
      ClickContinue(True, True);
      TileToArrive := Tile (0,0); // Failsafe
      case Direction of // Needs more randomness TBH
        'n': begin
                TileToArrive := Tile(FishObjTile.x, FishObjTile.y - 2);
                TileToFishAt := Tile(FishObjTile.x, FishObjTile.y);
                MakeCompass ('s');
             end;
        'e': begin
                TileToArrive := Tile(FishObjTile.x - 2, FishObjTile.y);
                TileToFishAt := Tile(FishObjTile.x, FishObjTile.y);
                MakeCompass ('w');
             end;
        's': begin
               TileToArrive := Tile(FishObjTile.x, FishObjTile.y + 2);
               TileToFishAt := Tile(FishObjTile.x, FishObjTile.y);
               MakeCompass ('n');
             end;
        'w': begin
               TileToArrive := Tile(FishObjTile.x + 2, FishObjTile.y);
               TileToFishAt := Tile(FishObjTile.x, FishObjTile.y);
               MakeCompass ('e');
             end;
      end;
      R_Debug('Direction and tiles set', 'ScapeRune');

      for i := 0 to 2 do
      begin
        TP := TileToMM(TileToArrive);
        if (TP.x > 0) and (TileToArrive.x > 0) then
        begin
          R_Debug('Walking attempt #' + ToStr(i), 'ScapeRune');
          Mouse (TP.x, TP.y, 2, 2, true);
          R_Flag;
          if (DistanceFrom(TileToArrive) < 4) then
          begin
            Result := True; // If we are near the spot then result = true
            R_Debug('Made it to: ' + ToStr(TileToArrive), 'ScapeRune');
            Exit;
          end;
        end else R_Debug('Error with walking to fishing spot', 'ScapeRune');
      end;
    end;
  end else R_Debug('Not in proper interface to get direction', 'ScapeRune');
end;

{*******************************************************************************
function R_ScapeRuneFishAtTile (TileToFishAt : TTile) : Boolean;
by: Cstrike
Description: Fishes the food for Bob at that tile. Returns true if it gets a
fish to [un]cook with.
*******************************************************************************}
function R_ScapeRuneFishAtTile (TileToFishAt : TTile) : Boolean;
var
  NPCs : TNPCArray;
  i, t, t2, t3, InviCount : Integer;
  TP : TPoint;
begin
  if not LoggedIn then Exit;
  Result := False;
  if (TileToFishAt.x < 1) then Exit;

  // Find if the inputted tile is a viable fishing tile
  MarkTime (t);
  repeat

    // Make sure were standing still
    MarkTime (t3);
    repeat
      wait (300);
    until (not Charactermoving) or (TimeFromMark(t3) > 5000)
    wait (650+random(350));

    // Find tile
    if TileOnMS (TileToFishAt, 0) then
    begin
      TP := TileToMS (TileToFishAt, 0);
      wait (250+random(150));
      case random(3) of
        0..1: Mouse (TP.x, TP.y, 2, 2, true);
        2..3: begin
                Mouse (TP.x, TP.y, 2, 2, false);
                R_ChooseOptionMulti (['fish', 'ish', 'net', 'et']); // Crap!
              end;
      end;
    end else
    begin
      NPCs := GetNPCsAt(TileToFishAt);
      for i:=0 to high(NPCs) do
      begin
        if (iAbs(NPCs[i].Tile.x - TileToFishAt.x) > 6) and (iAbs(NPCs[i].Tile.y - TileToFishAt.y) > 6) then
        begin
          if TileOnMS (TileToFishAt, 0) then
          begin
            TP := TileToMS (TileToFishAt, 0);
            case random(3) of
              0..1: Mouse (TP.x, TP.y, 2, 2, true);
              2..3: begin
                      Mouse (TP.x, TP.y, 2, 2, false);
                      R_ChooseOptionMulti (['fish', 'ish', 'net', 'et']); // Crap!
                    end;
            end;
            Break;
          end else R_Debug('Warning: Tile is not on the minimap!', 'ScapeRune');
        end;
      end;
    end;

    InviCount := R_InvCount; // Use this for detecting when we pickup fish

    // Now that we are fishing, wait until we catch something
    MarkTime (t2);
    repeat
      wait (50);
    until (TimeFromMark(t2) > 22000) or (InviCount < R_InvCount)

    if (InviCount < R_InvCount) then Result := True;
    wait (1000+random(1000));

  until (TimeFromMark(t) > 60000) or (InviCount < R_InvCount)
end;

{*******************************************************************************
function R_ScapeRuneCookFish : Boolean;
by: Cstrike
Description: Cooks the fish.
*******************************************************************************}
function R_ScapeRuneCookFish : Boolean;
var
  CookPots : TRSObjectArray;
  TP : TPoint;
  i, j, k : Integer;
begin
  if not LoggedIn then Exit;
  Result := False;
  for k:=1 to 3 do
  begin
    R_Debug('Attempt '+ToStr(k)+'/3 of cooking fish', 'ScapeRune');
    R_ScapeRuneWalkToCenter;
    CookPots := GetObjectsByIDEx ([R_EVILBOB_COOKINGPOT], OBJECT_TYPE_INTERACTABLE, 24);

    // Failsafe
    if high(CookPots) < 0 then
    begin
      R_Debug('Failed to find cooking pot to uncook', 'ScapeRune');
      Exit;
    end;

    // Try and find both, you never know if one has an error...
    for j:=1 to 2 do
    begin
      for i:=0 to high(CookPots) do
      begin
        R_ClickItemBy('Fish-like thing', false, 'Use');
        wait (500+random(500));
        if TileOnMS (CookPots[i].Tile, 0) then
        begin;
          TP := TileToMS (CookPots[i].Tile, 0);
          Mouse (TP.x, TP.y, 2, 2, true);
          if true then
          begin
            wait (4000+random(2200));
            if (R_CountItem('Raw') > 0) then
            begin
              R_Debug('Successfully made proper uncooked fish!', 'ScapeRune');
              Result := True;
              Exit;
            end else R_Debug('Was unable to cook ', 'ScapeRune');
          end else R_Debug('Error: ChooseOption Use was not present', 'ScapeRune');
        end else R_Debug('Pot #'+inttostr(i)+' not on MainScreen', 'ScapeRune');
      end;
    end;
  end;
end;

{*******************************************************************************
function R_ScapeRuneFinishRandom : Boolean;
by: Cstrike, fixed by Harry
Description: Gives that stupid cat its crap and leaves
*******************************************************************************}
function R_ScapeRuneFinishRandom : Boolean;
var
  t, i, TX, TY, ebobsrch: Integer;
  TP, TPPortal : TPoint;
  Portal : TRSObject;
  EvilThingArr: TNPCArray;
begin
  if not LoggedIn then Exit;
  Result := False;

  R_ClickItemBy('Raw fish-like', false, 'Use');
  wait(500+random(500));
  MakeCompass('n');
  wait(500+random(500))
  SetLength(EvilThingArr, 0);
  for ebobsrch := 1 to 4 do
  begin
    EvilThingArr := SortNPCs(GetNPCs('vil Bob'));
    try
      TP := TileToMS(EvilThingArr[0].Tile, R_EVILBOB_NPC_HEIGHT);
    except
      R_Debug('Failed to find Evil Bob?!','ScapeRune');
      Exit;
    end;
    Mouse(TP.X, TP.Y, 2, 2, False);
    Wait(10+Random(42))
    if R_ChooseOption('vil Bob') then
    begin
      Result := True;
      if (R_FlagExists) then
        R_Flag;
      R_Debug('Bob clicked, proceed.','ScapeRune');
      Break;
    end else
    begin
      R_Debug('Failed to give fish time '+toStr(ebobsrch)+'/4','ScapeRune');
      MMouse(MIX1, MIY1, MIX2, MIY2);
      Wait(42+Random(300));
    end;
  end;

  // Talk to bob
  MarkTime(t);
  repeat
    wait(50);
  until (ValidInterface(64)) or (TimeFromMark(t) > 10000)
  R_ScapeRuneClickContBobAll;

  // Enter portal here
  wait (500+random(500));
  for i:=1 to 3 do
  begin
    Portal := GetObjectByID(R_EVILBOB_PORTAL, OBJECT_TYPE_INTERACTABLE, 20);
    if TileOnMS(Portal.Tile, 0) then
    begin
      TPPortal := TileToMS (Portal.Tile, 0);
      Mouse(TPPortal.x, TPPortal.y, 3, 3, false);
      wait(400+random(400));
      if R_ChooseOption('Enter Portal') then
      begin
        R_Flag;

        Wait(1300 + Random(1000));

        if FindColor(TX, TY, 2070783, 234, 46, 254, 56) then
          Mouse(172, 199, 100, 4, True);

        R_Debug('Entering exit portal to finish random...', 'ScapeRune');
        Result := True;
        Exit;
      end else R_Debug('Had trouble finding "Enter Portal" ChooseOption', 'ScapeRune');
    end else R_ScapeRuneWalkToCenter;
    wait (1000+random(500));
  end;
end;

{*******************************************************************************
function R_SolveScapeRune : Boolean;
by: Cstrike
Description: Solves Evil Bob's ScapeRune random.
*******************************************************************************}
function R_SolveScapeRune : Boolean;
var
  i, t : Integer;
  FishingTile : TTile;
begin
  if not LoggedIn then Exit;
  Result := False;
  FishingTile := Tile(0,0); // Failsafe

  // Inventory failsafe
  if (R_CountItem(R_EVILBOB_SMALLFISHINGNET) = 0) then R_ScapeRuneDepositItems(1);

  R_ScapeRuneDestroyFish; // Cleans the plate

  for i:= 1 to 3 do
  begin
    R_Debug('ScapeRune solving attempt '+inttostr(i)+'/3', 'ScapeRune');
    if (R_ScapeRuneGetFishingNet) then
    begin
      if (R_ScapeRuneTalkToServantStart) then
      begin
        if (R_ScapeRuneDetermineDirectionOfFishAndWalkTo(FishingTile)) then
        begin
          if (R_ScapeRuneFishAtTile(FishingTile))then
          begin
            if (R_ScapeRuneCookFish) then
            begin
              if (R_ScapeRuneFinishRandom) then
              begin
                R_Debug('Evil Bobs ScapeRune solved!', 'ScapeRune');
                Result := True;
                Break;
              end else R_Debug('Had trouble giving fish to bob and/or finishing random', 'ScapeRune');
            end else R_Debug('Had trouble cooking the fish', 'ScapeRune');
          end else R_Debug('Had trouble fishing at specified tile', 'ScapeRune');
        end else R_Debug('Had trouble determining direction of fishing and walking to that spot', 'ScapeRune');
      end else R_Debug('Had trouble talking to Servant', 'ScapeRune');
    end else R_Debug('Had trouble getting fishing net', 'ScapeRune');
    R_ScapeRuneDestroyFish; // Just incase
  end; // End of 3 tries
  if not Result then R_Debug('Failed 3x the ScapeRune random, returning false...', 'ScapeRune');
  MarkTime(t);
  while (R_InScapeRune and (TimeFromMark(t) < 8000)) do
      Wait(1500);
  R_Debug('Out of ScapeRune', 'ScapeRune');
  Wait(2500);
  ClickToContinue;
  Wait(4000+Random(2000));
  Result := not R_InScapeRune;
end;
