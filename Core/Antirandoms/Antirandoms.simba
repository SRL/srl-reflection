const
  r_RandomCount = 18;

  R_RANDOM_ABYSS = 0;
  R_RANDOM_BEEKEEPER = 1;
  R_RANDOM_CAPNARRAV = 2;
  R_RANDOM_CERTER = 3;
  R_RANDOM_DRILLDEMON = 4;
  R_RANDOM_EVILBOB = 5;
  R_RANDOM_EXAM = 6;
  R_RANDOM_FREAKYFORESTER = 7;
  R_RANDOM_FROG = 8;
  R_RANDOM_GRAVEDIGGER = 9;
  R_RANDOM_MAZE = 10;
  R_RANDOM_MIME = 11;
  R_RANDOM_MOLLY = 12;
  R_RANDOM_PILLORY = 13;
  R_RANDOM_PINBALL = 14;
  R_RANDOM_PRISON = 15;
  R_RANDOM_QUIZ = 16;
  R_RANDOM_SANDWICHLADY = 17;

type
  r_Random = Record
    RandName, Music: String;
    InRandom, SolveRandom: function: Boolean;
  end;

var
  r_RandomArr: Array [0..17] of r_Random;
  r_RandomVarSet: Boolean;

Procedure r_SetupRandoms;
begin
  With r_RandomArr[R_RANDOM_ABYSS] do
  begin
    RandName := 'Abyss';
    Music := 'into the abyss';
    InRandom := @R_InAbyss;
    SolveRandom := @R_SolveAbyss;
  end;

  With r_RandomArr[R_RANDOM_BEEKEEPER] do
  begin
    RandName := 'Beekeeper';
    Music := ''; // Wheres the music?
    InRandom := @r_InBeekeeper;
    SolveRandom := @R_SolveBeekeeper;
  end;

  // Needs deposit
  // BTW N1ke, this is "capn arNav" :P
  With r_RandomArr[R_RANDOM_CAPNARRAV] do
  begin
    RandName := 'Cap n'' Arrav';
    Music := 'sea shanty';
    InRandom := @R_InArnav;
    SolveRandom := @R_SolveArnav;
  end;

  With r_RandomArr[R_RANDOM_CERTER] do
  begin
    RandName := 'Certer';
    Music := ''; //'start', 'unknown land', 'dream', 'autumn voyage';
    InRandom := @R_InCerter;
    SolveRandom := @R_SolveCerter;
  end;

  With r_RandomArr[R_RANDOM_DRILLDEMON] do
  begin
    RandName := 'Drill Demon';
    Music := 'corporal punishment';
    InRandom := @R_InDemon;
    SolveRandom := @R_SolveDemon;
  end;

  // Needs deposit
  With r_RandomArr[R_RANDOM_EVILBOB] do
  begin
    RandName := 'Evilbob';
    Music := 'evil bob''s island';
    InRandom := @R_InScapeRune;
    SolveRandom := @R_SolveScapeRune;
  end;

  With r_RandomArr[R_RANDOM_EXAM] do
  begin
    RandName := 'Exam';
    Music := 'school''s out';
    InRandom := @R_InMordaut;
    SolveRandom := @R_SolveMordaut;
  end;

  // Needs deposit
  With r_RandomArr[R_RANDOM_FREAKYFORESTER] do
  begin
    RandName := 'Freaky forester';
    Music := 'pheasant peasant';
    InRandom := @R_InForester;
    SolveRandom := @R_SolveForester;
  end;

  With r_RandomArr[R_RANDOM_FROG] do
  begin
    RandName := 'Frog';
    Music := 'frogland';
    InRandom := @R_InFrogCave;
    SolveRandom := @R_SolveFrogCave;
  end;

  // Needs deposit
  With r_RandomArr[R_RANDOM_GRAVEDIGGER] do
  begin
    RandName := 'Gravedigger';
    Music := 'spooky';
    InRandom := @r_InLeo;
    SolveRandom := @r_SolveLeo;
  end;

  With r_RandomArr[R_RANDOM_MAZE] do
  begin
    RandName := 'Maze';
    Music := 'time out';
    InRandom := @r_InMaze;
    SolveRandom := @r_SolveMaze;
  end;

  With r_RandomArr[R_RANDOM_MIME] do
  begin
    RandName := 'Mime';
    Music := 'artistry';
    InRandom := @R_InMime;
    SolveRandom := @R_SolveMime;
  end;

  With r_RandomArr[R_RANDOM_MOLLY] do
  begin
    RandName := 'Molly';
    Music := 'head to head';
    InRandom := @R_InMolly;
    SolveRandom := @R_SolveMolly;
  end;

  // This is just broken to hell
  With r_RandomArr[R_RANDOM_PILLORY] do
  begin
    RandName := 'Pillory';
    Music := ''; // NEED MUSIC
    InRandom := nil;
    SolveRandom := nil;
  end;

  With r_RandomArr[R_RANDOM_PINBALL] do
  begin
    RandName := 'Pinball';
    Music := 'pinball wizard';
    InRandom := @R_InPinball;
    SolveRandom := @R_SolvePinball;
  end;

  // Needs deposit
  With r_RandomArr[R_RANDOM_PRISON] do
  begin
    RandName := 'Prison';
    Music := 'in the clink';
    InRandom := @R_InPrison;
    SolveRandom := nil; // Not complete
  end;

  With r_RandomArr[R_RANDOM_QUIZ] do
  begin
    RandName := 'Quiz';
    Music := 'the quiz master';
    InRandom := @R_InQuiz;
    SolveRandom := @R_SolveQuizMaster;
  end;

  With r_RandomArr[R_RANDOM_SANDWICHLADY] do
  begin
    RandName := 'Sandwhich lady';
    Music := 'snack attack';
    InRandom := @r_InSandwichLadyRandom;
    SolveRandom := @r_SolveSandwichRandom;
  end;

  r_RandomVarSet := True;
end;

{*******************************************************************************
function FindLamp(skill: String): Boolean;
by: Pups, Starblaster100,PriSoner, Lee Lok Hin, Timer
Description: handles Genie. Results True if lamp found and handled.
skill: Skill to use with lamp eg. 'strength', 'attack', etc.
*******************************************************************************}
function R_FindLamp(skill: string): Boolean;
var
  LampTime, X, Y, I: Integer;
  lamp: TInvItem;
begin
  GameTab(tab_Inv);
  if(R_ItemIDExists(lamp, 2528))then
  begin
    Result := True;
    Inc(RandSolved[rand_Lamp]);
    AddToSRLLog('******** SOLVED LAMP RANDOM ********');
    WriteLn('******** SOLVED LAMP RANDOM ********');
    MouseItem(lamp.slot, true);
    Wait(1500 + Random(500));
    MarkTime(LampTime);
    for I := 1 to 4 do
    begin
      case (LowerCase(Skill)) of
        'attack': Mouse(81, 109, 12, 12, True);
        'strength': Mouse(139, 110, 12, 12, True);
        'ranged': Mouse(196, 113, 12, 12, True);
        'magic': Mouse(257, 117, 12, 12, True);
        'defence': Mouse(319, 109, 12, 12, True);
        'crafting', 'craft': Mouse(376, 111, 12, 12, True);
        'hitpoints', 'hp': Mouse(436, 112, 12, 12, True);
        'prayer', 'pray': Mouse(79, 166, 12, 12, True);
        'agility': Mouse(141, 166, 12, 12, True);
        'herblore': Mouse(199, 171, 12, 12, True);
        'thieving', 'thief': Mouse(258, 167, 12, 12, True);
        'fishing', 'fish': Mouse(325, 164, 12, 12, True);
        'runecraft', 'runecrafting': Mouse(375, 167, 12, 12, True);
        'slayer', 'slay': Mouse(436, 173, 12, 12, True);
        'farming', 'farm': Mouse(83, 224, 12, 12, True);
        'mining', 'mine': Mouse(137, 222, 12, 12, True);
        'smithing', 'smith': Mouse(197, 220, 12, 12, True);
        'hunting', 'hunt', 'hunter': Mouse(257, 222, 12, 12, True);
        'cooking', 'cook': Mouse(318, 227, 12, 12, True);
        'firemaking', 'fire': Mouse(378, 226, 12, 12, True);
        'woodcutting', 'wc': Mouse(439, 222, 12, 12, True);
        'fletching', 'fletch': Mouse(199, 275, 12, 12, True);
        'construction': Mouse(255, 277, 12, 12, True);
        'summoning': Mouse(323, 276, 12, 12, True);
      else
        Mouse(438, 113, 12, 12, True);
      end;
      Wait(750 + Random(200) + Random(100));
      if FindColorTolerance(X, Y, 5602449, 41, 75, 470, 302, 30) then Break;
      if (TimeFromMark(LampTime) > 10000) then
      begin
        Result := False;
        Logout;
        Players[CurrentPlayer].Rand := 'Lamp';
        Exit;
      end;
      ClickToContinue;
    end;
    Mouse(416, 281, 7, 1, True);
    Wait(1111 + Random(150) + Random(150));
    while ClickContinue(true,true) do
      wait(500+random(100));
  end;
end;

function r_GetMusic: String;
begin
  Result := GetInterfaceText(187, 4);
end;

function R_SolveNonTalkingRandoms : Boolean;
var
  I, iTime: Integer;
  Music: String;
  InRand: Boolean;
  T: TTile;
  RandomBox: TBox;
begin
  If Not LoggedIn then
    Exit;

  If Not r_RandomVarSet then
    r_SetupRandoms;

  Music := LowerCase(r_GetMusic);
  for I := 0 to r_RandomCount-1 do
  begin

    If (r_RandomArr[I].Music = Music)or(r_RandomArr[I].Music = '')then
      if (r_RandomArr[I].InRandom <> nil) then
        InRand := r_RandomArr[I].InRandom()
      else
      begin
        if (not(r_RandomArr[I].InRandom <> nil)and(r_RandomArr[I].Music = ''))then
           Continue;
        Writeln('[Reflection] Might be in a random(missing InRandom function), terminating.');
        Players[CurrentPlayer].Rand := r_RandomArr[I].RandName;
        LogOut;
        Exit;
      end;

    if (InRand) then
    begin
      Players[CurrentPlayer].Rand := r_RandomArr[I].RandName;
      Writeln('[Reflection] Trying to solve: ' + r_RandomArr[I].RandName);
      T := GetMyPos;
      RandomBox := IntToBox(T.X-70, T.Y-70, T.X+70, T.Y+70);

      if (r_RandomArr[I].SolveRandom <> nil) then
      begin
        SetAngle(True);
        Result := r_RandomArr[I].SolveRandom()
      end else
      begin
        Writeln('[Reflection] No random solver for this random yet!');
        Logout;
        Players[CurrentPlayer].Active := False;
        Exit;
      end;

      if (not Result) then
      begin
        Writeln('[Reflection] Random solving for ' + r_RandomArr[I].RandName + ' failed');
        Logout;
        Players[CurrentPlayer].Active := False;
        Exit;
      end else
        Writeln('[Reflection] Random solved');

      iTime := GetSystemTime;
      While TileInBox(RandomBox, GetMyPos)do
      begin
        Wait(1000+Random(1500));
        If (GetSystemTime - iTime > 30000)then
          Exit;
      end;
      Wait(2000+Random(1000));

      Players[CurrentPlayer].Rand := '';


      UseRewardBox;
      Exit;
    end;

  end;
end;

{*******************************************************************************
function R_FindRandoms: Boolean;
By: Nava2
Description: Calls the random checks.
*******************************************************************************}
function R_FindRandoms: Boolean;
begin
  Result := R_SolveNonTalkingRandoms;
  if (Result) then
  begin
    if (SRL_Procs[srl_OnFindRandom] <> nil) then
      SRL_Procs[srl_OnFindRandom]();
  end;
end;

{*******************************************************************************
function R_FindRandomsDeposit (ItemsToNotDeposit : TIntegerArray): Boolean;
By: Nava2, modded by Cstrike
Description: Does random checks, and once developed, will deposit items you
specifiy for randoms so you don't lose anything precious.
*******************************************************************************}
{
function R_FindRandomsDeposit (ItemsToNotDeposit : TIntegerArray) : Boolean;
begin
  Result := R_SolveNonTalkingRandoms (ItemsToNotDeposit);
  if (Result) then
  begin
    if (SRL_Procs[srl_OnFindRandom] <> nil) then
      SRL_Procs[srl_OnFindRandom]();
  end;
end;
}

{*******************************************************************************
function R_OnFindRandomCall(var Cont : boolean) : boolean;
Description: This event is called when SRL calls the FindNormalRandoms procedure.
Thus it will always try to solve the randoms by using reflection first!
*******************************************************************************}
function R_OnFindRandomCall(var Cont : boolean) : boolean;
begin
  Result := R_FindRandoms;
  Cont := not Result;
end;
